<html><head><title>Go generics in action</title><link rel="stylesheet" href="/go-blog/static/bootstrap.min.css"><link rel="stylesheet" href="/go-blog/static/style.css"></head><body class="article-container"><nav><ol class="breadcrumb p-3"><li class="breadcrumb-item"><a href="#">home</a></li><li class="breadcrumb-item active"><a href="/">oscar</a></li><li class="breadcrumb-item active"><a href="/go-blog/2025">2025</a></li><li class="breadcrumb-item active"><a href="/go-blog/2025/11">November</a></li><li class="breadcrumb-item active">30</li><li class="breadcrumb-item active"><a href="/go-blog/2025/11/30/Go generics in action">Go generics in action</a></li></ol></nav><main><h1 class="fw-bold display-5 display-md-3">Go generics in action</h1><p>Generics in Go arrived really late on version 1.18, and with reason, as its <em>usage should be reserved strictly when necessary</em>. There's very few cases when making use of a generic makes sense, for example an <code>assert</code>-like type of function:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span><span style="color:#fe8019">func</span> Equal[T comparable](t <span style="color:#fe8019">*</span>testing.T, actual, expected T) {
</span></span><span style="display:flex;"><span>	t.<span style="color:#fabd2f">Helper</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fe8019">if</span> actual <span style="color:#fe8019">!=</span> expected {
</span></span><span style="display:flex;"><span>		t.<span style="color:#fabd2f">Errorf</span>(<span style="color:#b8bb26">&#34;got: %v; want: %v&#34;</span>, actual, expected)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><blockquote>
<p><code>t.Helper()</code> <em>returns</em> the error back up to the caller to avoid showing the <code>file:line</code> error message on this function</p>
</blockquote>
<p>A useless example, but that helps explain type restriction:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span><span style="color:#fe8019">func</span> SumIntsOrFloats[K comparable, V <span style="color:#fabd2f">int64</span> | <span style="color:#fabd2f">float64</span>](m <span style="color:#fe8019">map</span>[K]V) V {
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">var</span> s V
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">for</span> _, v <span style="color:#fe8019">:=</span> <span style="color:#fe8019">range</span> m {
</span></span><span style="display:flex;"><span>        s <span style="color:#fe8019">+=</span> v
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fe8019">return</span> s
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Note that <code>comparable</code> is just an interface similar to this one:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span><span style="color:#fe8019">type</span> Number <span style="color:#fe8019">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fabd2f">int64</span> | <span style="color:#fabd2f">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre><p>Which just helps <em>restrict</em> the kind of values this generic can be.</p>
</main></body></html>